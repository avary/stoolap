package test

import (
	"testing"

	"github.com/semihalev/stoolap/internal/storage/mvcc"
)

func TestRowBitmap_BasicOperations(t *testing.T) {
	// Create a new bitmap
	rb := mvcc.NewRowBitmap(100)
	defer rb.ReturnToPool()

	// Test initial state
	if rb.Count() != 0 {
		t.Errorf("New bitmap should have count 0, got %d", rb.Count())
	}

	// Test Set and IsSet
	rb.Set(5)
	rb.Set(10)
	rb.Set(64) // Test beyond a single word boundary

	if !rb.IsSet(5) {
		t.Error("Bit 5 should be set")
	}
	if !rb.IsSet(10) {
		t.Error("Bit 10 should be set")
	}
	if !rb.IsSet(64) {
		t.Error("Bit 64 should be set")
	}
	if rb.IsSet(6) {
		t.Error("Bit 6 should not be set")
	}

	// Test Count
	if rb.Count() != 3 {
		t.Errorf("Expected count 3, got %d", rb.Count())
	}

	// Test Unset
	rb.Unset(10)
	if rb.IsSet(10) {
		t.Error("Bit 10 should not be set after Unset")
	}
	if rb.Count() != 2 {
		t.Errorf("Expected count 2 after Unset, got %d", rb.Count())
	}

	// Test Reset
	rb.Reset()
	if rb.Count() != 0 {
		t.Errorf("Expected count 0 after Reset, got %d", rb.Count())
	}
}

func TestRowBitmap_Resize(t *testing.T) {
	// Create a bitmap with small initial capacity
	rb := mvcc.NewRowBitmap(10)
	defer rb.ReturnToPool()

	// Test auto-resize on Set
	rb.Set(1000)
	if !rb.IsSet(1000) {
		t.Error("Bit 1000 should be set after auto-resize")
	}
	if rb.Size() <= 1000 {
		t.Errorf("Bitmap size should be larger than 1000 after auto-resize, got %d", rb.Size())
	}

	// Test explicit resize
	rb.Resize(5000)
	if rb.Size() < 5000 {
		t.Errorf("Bitmap size should be at least 5000 after resize, got %d", rb.Size())
	}
	// Ensure the bit is still set after resize
	if !rb.IsSet(1000) {
		t.Error("Bit 1000 should still be set after resize")
	}
}

func TestRowBitmap_ForEach(t *testing.T) {
	// Create a new bitmap
	rb := mvcc.NewRowBitmap(100)
	defer rb.ReturnToPool()

	// Set some bits
	setIDs := []int64{5, 10, 64, 99}
	for _, id := range setIDs {
		rb.Set(id)
	}

	// Test ForEach
	visited := make(map[int64]bool)
	rb.ForEach(func(rowID int64) {
		visited[rowID] = true
	})

	if len(visited) != len(setIDs) {
		t.Errorf("ForEach visited %d bits, expected %d", len(visited), len(setIDs))
	}

	for _, id := range setIDs {
		if !visited[id] {
			t.Errorf("ForEach did not visit bit %d", id)
		}
	}
}

func TestRowBitmap_ForEachBatch(t *testing.T) {
	// Create a new bitmap
	rb := mvcc.NewRowBitmap(1000)
	defer rb.ReturnToPool()

	// Set a lot of bits
	for i := int64(0); i < 100; i++ {
		rb.Set(i * 7) // Set every 7th bit
	}

	// Test ForEachBatch with batch size 10
	var allIDs []int64
	batchCount := 0

	rb.ForEachBatch(10, func(batch []int64) {
		// Each batch except the last should have exactly 10 items
		if batchCount < 9 && len(batch) != 10 {
			t.Errorf("Batch %d had %d items, expected 10", batchCount, len(batch))
		}
		// The last batch might have fewer items
		allIDs = append(allIDs, batch...)
		batchCount++
	})

	if int64(len(allIDs)) != rb.Count() {
		t.Errorf("ForEachBatch collected %d IDs, expected %d", len(allIDs), rb.Count())
	}

	// Verify we got the right IDs
	for i := int64(0); i < 100; i++ {
		id := i * 7
		found := false
		for _, collectedID := range allIDs {
			if collectedID == id {
				found = true
				break
			}
		}
		if !found {
			t.Errorf("ID %d not found in batch results", id)
		}
	}
}

func TestRowBitmap_SetOperations(t *testing.T) {
	// Create two bitmaps
	rb1 := mvcc.NewRowBitmap(100)
	defer rb1.ReturnToPool()
	rb2 := mvcc.NewRowBitmap(100)
	defer rb2.ReturnToPool()

	// Set bits in first bitmap: 1, 3, 5, 7, 9
	for i := int64(1); i < 10; i += 2 {
		rb1.Set(i)
	}

	// Set bits in second bitmap: 5, 7, 9, 11, 13
	for i := int64(5); i < 15; i += 2 {
		rb2.Set(i)
	}

	// Test Union
	rb1Copy := mvcc.NewRowBitmap(100)
	defer rb1Copy.ReturnToPool()
	// Copy rb1 to rb1Copy
	for i := int64(0); i < rb1.Size(); i++ {
		if rb1.IsSet(i) {
			rb1Copy.Set(i)
		}
	}

	rb1Copy.Union(rb2)
	// Union should be 1, 3, 5, 7, 9, 11, 13
	expectedUnion := []int64{1, 3, 5, 7, 9, 11, 13}
	for _, id := range expectedUnion {
		if !rb1Copy.IsSet(id) {
			t.Errorf("Union should have bit %d set", id)
		}
	}
	if rb1Copy.Count() != int64(len(expectedUnion)) {
		t.Errorf("Union should have %d bits set, got %d", len(expectedUnion), rb1Copy.Count())
	}

	// Test Intersect
	rb1Copy = mvcc.NewRowBitmap(100)
	defer rb1Copy.ReturnToPool()
	// Copy rb1 to rb1Copy
	for i := int64(0); i < rb1.Size(); i++ {
		if rb1.IsSet(i) {
			rb1Copy.Set(i)
		}
	}

	rb1Copy.Intersect(rb2)
	// Intersection should be 5, 7, 9
	expectedIntersect := []int64{5, 7, 9}
	for _, id := range expectedIntersect {
		if !rb1Copy.IsSet(id) {
			t.Errorf("Intersect should have bit %d set", id)
		}
	}
	if rb1Copy.Count() != int64(len(expectedIntersect)) {
		t.Errorf("Intersect should have %d bits set, got %d", len(expectedIntersect), rb1Copy.Count())
	}

	// Test Difference
	rb1Copy = mvcc.NewRowBitmap(100)
	defer rb1Copy.ReturnToPool()
	// Copy rb1 to rb1Copy
	for i := int64(0); i < rb1.Size(); i++ {
		if rb1.IsSet(i) {
			rb1Copy.Set(i)
		}
	}

	rb1Copy.Difference(rb2)
	// Difference should be 1, 3
	expectedDiff := []int64{1, 3}
	for _, id := range expectedDiff {
		if !rb1Copy.IsSet(id) {
			t.Errorf("Difference should have bit %d set", id)
		}
	}
	if rb1Copy.Count() != int64(len(expectedDiff)) {
		t.Errorf("Difference should have %d bits set, got %d", len(expectedDiff), rb1Copy.Count())
	}
}

func TestRowBitmap_ToSliceAndFromSlice(t *testing.T) {
	// Create a bitmap and set some bits
	rb := mvcc.NewRowBitmap(100)
	defer rb.ReturnToPool()

	ids := []int64{1, 5, 10, 64, 99}
	for _, id := range ids {
		rb.Set(id)
	}

	// Convert to slice
	slice := rb.ToSlice()
	if len(slice) != len(ids) {
		t.Errorf("ToSlice returned %d items, expected %d", len(slice), len(ids))
	}

	// Verify all items are in the slice
	for _, id := range ids {
		found := false
		for _, sliceID := range slice {
			if sliceID == id {
				found = true
				break
			}
		}
		if !found {
			t.Errorf("ID %d not found in slice", id)
		}
	}

	// Create a new bitmap from the slice
	rb2 := mvcc.NewRowBitmap(100)
	defer rb2.ReturnToPool()
	rb2.FromSlice(slice)

	// Verify the new bitmap has the same bits set
	if rb2.Count() != int64(len(ids)) {
		t.Errorf("FromSlice set %d bits, expected %d", rb2.Count(), len(ids))
	}
	for _, id := range ids {
		if !rb2.IsSet(id) {
			t.Errorf("Bit %d not set after FromSlice", id)
		}
	}
}

func BenchmarkRowBitmap_Set(b *testing.B) {
	rb := mvcc.NewRowBitmap(10000)
	defer rb.ReturnToPool()

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		rb.Set(int64(i % 10000))
	}
}

func BenchmarkRowBitmap_IsSet(b *testing.B) {
	rb := mvcc.NewRowBitmap(10000)
	defer rb.ReturnToPool()

	// Set every other bit
	for i := int64(0); i < 10000; i += 2 {
		rb.Set(i)
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		rb.IsSet(int64(i % 10000))
	}
}

func BenchmarkRowBitmap_ForEach(b *testing.B) {
	rb := mvcc.NewRowBitmap(10000)
	defer rb.ReturnToPool()

	// Set 1000 random bits
	for i := 0; i < 1000; i++ {
		rb.Set(int64(i * 7))
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		count := 0
		rb.ForEach(func(rowID int64) {
			count++
		})
	}
}

func BenchmarkRowBitmap_ForEachBatch(b *testing.B) {
	rb := mvcc.NewRowBitmap(10000)
	defer rb.ReturnToPool()

	// Set 1000 random bits
	for i := 0; i < 1000; i++ {
		rb.Set(int64(i * 7))
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		count := 0
		rb.ForEachBatch(100, func(batch []int64) {
			count += len(batch)
		})
	}
}

func BenchmarkRowBitmap_Count(b *testing.B) {
	rb := mvcc.NewRowBitmap(10000)
	defer rb.ReturnToPool()

	// Set 1000 random bits
	for i := 0; i < 1000; i++ {
		rb.Set(int64(i * 7))
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		rb.Count()
	}
}

func BenchmarkRowBitmap_Union(b *testing.B) {
	rb1 := mvcc.NewRowBitmap(10000)
	defer rb1.ReturnToPool()
	rb2 := mvcc.NewRowBitmap(10000)
	defer rb2.ReturnToPool()

	// Set some bits in both bitmaps
	for i := int64(0); i < 10000; i += 2 {
		rb1.Set(i)
	}
	for i := int64(0); i < 10000; i += 3 {
		rb2.Set(i)
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		rb1Copy := mvcc.NewRowBitmap(10000)
		// Copy rb1 to rb1Copy
		for i := int64(0); i < rb1.Size(); i++ {
			if rb1.IsSet(i) {
				rb1Copy.Set(i)
			}
		}
		rb1Copy.Union(rb2)
		rb1Copy.ReturnToPool()
	}
}
